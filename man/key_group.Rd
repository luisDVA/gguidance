% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/key-group.R
\name{key_group}
\alias{key_group}
\alias{key_group_auto}
\alias{key_group_lut}
\title{Group keys}
\usage{
key_group_auto(sep = "[^[:alnum:]]+", reverse = FALSE)

key_group_lut(members, group, ungrouped = "Other")
}
\arguments{
\item{sep}{A \verb{<character[1]>} giving a \link[base:regex]{regular expression} to
use for splitting labels provided by the scale using
\code{\link[base:strsplit]{strsplit()}}. Defaults to splitting on any
non-alphanumeric character.}

\item{reverse}{A \verb{<logical[1]>} which if \code{FALSE} (default) treats the first
part of the split string as groups, and if \code{TRUE} treats the last part
as groups.}

\item{members}{A vector including the scale's \code{breaks} values.}

\item{group}{A vector parallel to \code{members} giving the group of every member.}

\item{ungrouped}{A \verb{<character[1]>} giving a group label to assign to the
scale's \code{breaks} that match no values in the \code{members} argument.}
}
\value{
For \code{key_group_auto()} and \code{key_group_lut()}, a function.
}
\description{
These functions are helper function for working with grouped data as keys in
guides. They all share the goal of creating a guide key, but have different
methods.
\itemize{
\item \code{key_group_auto()} is a function factory whose functions make an attempt
to infer groups from the scale's labels.
\item \code{key_group_lut()} is a function factory whose functions use a look up table
to sort out group membership.
}
}
\details{
The resulting key is always sorted by group.
The \code{key_group_auto()} does \emph{not} work with expression labels.
}
\examples{
# Example scale
values <- c("group A:value 1", "group A:value 2", "group B:value 1")
template <- scale_colour_discrete(limits = values)

# Treat the 'group X' part as groups
auto <- key_group_auto(sep = ":")
auto(template)

# Treat the 'value X' part as groups
auto <- key_group_auto(sep = ":", reverse = TRUE)
auto(template)

# Example scale
template <- scale_colour_discrete(limits = msleep$name[c(1, 7, 9, 23, 24)])

# A lookup table can have more entries than needed
lut <- key_group_lut(msleep$name, msleep$order)
lut(template)

# Or less entries than needed
lut <- key_group_lut(
  msleep$name[23:24], msleep$order[23:24],
  ungrouped = "Other animals"
)
lut(template)
}
\seealso{
Other keys: 
\code{\link{key_range}},
\code{\link{key_specialty}},
\code{\link{key_standard}}
}
\concept{keys}
